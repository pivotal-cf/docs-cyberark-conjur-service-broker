---
title: Using CyberArk Conjur Service Broker for PCF
owner: Partners
---

This topic describes how to use CyberArk Conjur Service Broker for Pivotal Cloud Foundry (PCF).

##<a id='using'></a> Using CyberArk Conjur Service Broker for PCF

The CyberArk Conjur Service Broker for PCF provides the interface between PCF applications and a Conjur appliance. 

 - [Deploy a PCF Application that Accesses Secrets from Conjur](#deploy-application)
 
 - [Use a Custom Buildpack](#custom-bp)
 
###<a id='deploy-application'></a>Deploy a PCF Application that Accesses Secrets from Conjur   

This procedure enables a PCF application to obtain secrets and manage authorization privileges from an existing Conjur appliance.

You can push the same application to multiple spaces. After preparing the application as described in Step 1 below, target your desired orgs and spaces and perform the remaining steps for each space.    

 - [Step 1: Prepare the Application](#secrets)
 - [Step 2: Create a Service Instance](#create-service)
 - [Step 3: Edit Manifest File](#edit-manifest)
 - [Step 4: Push Application to PCF Space](#push-app)
 - [Step 5: Obtain the Binding ID](#bind)
 - [Step 6: Update the Conjur Policy File with the Binding ID](#update-policy)
 - [Step 7: Restage the Application](#restage)

####<a id="secrets"></a>Step 1: Prepare the Application

The CyberArk Conjur Service Broker for PCF uses the Summon application included in the Conjur Buildpack by default to fetch secrets from the Conjur appliance and inject the values into your application's environment.  
The secrets, fetched at application startup, are available only to the application process (not to users), and are gone when the process exits.  
Summon requires a `secrets.yml` file in the application's root folder. 

If your application uses another method to access secrets, such as Conjur API calls, you do not need a `secrets.yml` file.  

  1. Create a file named `secrets.yml`.
 
  2. Add entries to the file to define the secrets that the application will fetch from the Conjur appliance.
 
  2. Store the `secrets.yml` file in the root folder of your application. 

The following example of a `secrets.yml` file shows several types of allowed entries.  
 
```
AWS_ACCESS_KEY_ID: !var aws/$environment/iam/user/robot/access_key_id
AWS_SECRET_ACCESS_KEY: !var aws/$environment/iam/user/robot/secret_access_key
AWS_REGION: us-east-1
SSL_CERT: !var:file ssl/certs/private
```

Lines 1 and 2 specify variables with pathnames containing the secret.
Line 3 specifies a literal string for the secret. 
Line 4 specifies a variable that is a file containing the secret.

In the context of a PCF environment, the above example could produce the following results: 
 
```
AWS_ACCESS_KEY_ID: AKIAI44QH8DHBEXAMPLE
AWS_SECRET_ACCESS_KEY: je7MtGbClwBF/2Zp9Utk/h3yCo8nvbEXAMPLEKEY
AWS_REGION: us-east-1
SSL_CERT: /tmp/ssl-cert.pem
```
 
For more information about syntax and options for a `secrets.yml` file, see the secrets.yml section [in the Summon documentation](https://cyberark.github.io/summon/). 


####<a id="create-service"></a>Step 2: Create a Service Instance  

In the PCF space where you intend to deploy the application, create a service instance.   
 
<pre class='term'>$ cf create-service cyberark-conjur community <my-service-instance-name></pre>

In the command above:

* The service-name is `cyberark-conjur`. 
* There is a single free service plan called `community`.
* For convenience, you may use the same instance-name in multiple PCF spaces, so that the same application manifest works in all spaces.      

 
####<a id="edit-manifest"></a>Step 3: Edit Application Manifest  

Add the instance-name from the previous step to the list of services in the application manifest (if you are using a manifest).  For example: 
 
   ```
 applications:
  - name: <my-app>
    services:
    - <my-service-instance-name> 
   ```
 

####<a id="push-app"></a>Step 4: Push Application to PCF Space

If your application lists buildpacks in its manifest, see [Use a Custom BuildPack](#custom-bp) before proceeding with this step.    

Target your desired orgs and spaces and push the application and its associated files. 

```
cf push ...   
```
Use the `--no-start` option to avoid starting the application before it is configured to work with Conjur.

 
####<a id="bind"></a>Step 5: Obtain the Binding ID  

Binding occurs automatically if the application manifest contains the correct service instance name. If you are not using a manifest, run the `cf bind-service` command to bind the application manually. For example: 

<pre class='term'>$ cf bind-service <my-app> <my-service-instance-name></pre>

The binding process generates a binding ID that becomes the Conjur host ID, used as a unique application identity for this application running in this space.

The ID is stored in the `authn_login` string found under the VCAP_SERVICES environment variable. The `authn_login` string has the format `host/<id>`. For example:   
  
    `host/0299a19d-7de4-4e98-89f6-372ac7c0521f`

The following command extracts just the ID value that you need. 
 
<pre class='term'>$ cf env $APP_NAME | grep authn_login | awk '{print $NF}' | sed 's/host\///g; s/"//g'</pre>

####<a id="update-policy"></a>Step 6: Update Conjur Policy Grants for this Application      

The binding ID obtained in the previous step becomes the host ID to use in Conjur policies.  

 1. Log into the Conjur appliance.   
 
 2. Update Conjur policy to add the new host ID with read and execute privilege on a set of secrets. 
   
   For example, the policy snippet below adds the new host to an existing group.  
  
   ``` 
   - !grant
     role: !group /path/to/some/app/secrets-users
     member: !host 0299a19d-7de4-4e98-89f6-372ac7c0521f
   ```
   
 If you save the policy to a file named `entitlements.yml`, you can load the policy into Conjur using the Conjur CLI. For example:  
 
<pre class='term'>$ conjur policy load my-policy /path/to/entitlements.yml</pre>


####<a id="restage"></a>Step 7: Restage the Application 
  
Start or restage the application. 

<pre class='term'>$ cf restage my-app</pre>

On application startup, the service loads the secrets that are defined in the application's `secrets.yml` into the PCF environment. 


###<a id='custom-bp'></a>Use a Custom Buildpack

The `cf push` command in the previous procedure defaults to using the buildpacks included in CyberArk Conjur Service Broker for PCF. If your application uses a custom buildpack,  such as a node.js buildpack, see the following file for instructions.  

[https://github.com/cyberark/cloudfoundry-conjur-buildpack/blob/master/README.md]()
   



 



